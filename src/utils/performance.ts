// Performance optimization utilities

// Resource hints for preloading critical resources
export const addResourceHints = () => {
  const head = document.head;

  // DNS prefetch for external domains
  const dnsPrefetchDomains = [
    'fonts.googleapis.com',
    'fonts.gstatic.com',
    'cdn.jsdelivr.net'
  ];

  dnsPrefetchDomains.forEach(domain => {
    const link = document.createElement('link');
    link.rel = 'dns-prefetch';
    link.href = `//${domain}`;
    head.appendChild(link);
  });

  // Preconnect to critical external resources
  const preconnectDomains = [
    'https://fonts.googleapis.com',
    'https://fonts.gstatic.com'
  ];

  preconnectDomains.forEach(domain => {
    const link = document.createElement('link');
    link.rel = 'preconnect';
    link.href = domain;
    link.crossOrigin = 'anonymous';
    head.appendChild(link);
  });
};

// Preload critical CSS and JS chunks
export const preloadCriticalResources = () => {
  const criticalResources = [
    // Add critical CSS files
    '/assets/index.css',
    // Add critical JS chunks (these will be generated by Vite)
  ];

  criticalResources.forEach(resource => {
    const link = document.createElement('link');
    link.rel = 'preload';
    
    if (resource.endsWith('.css')) {
      link.as = 'style';
    } else if (resource.endsWith('.js')) {
      link.as = 'script';
    }
    
    link.href = resource;
    document.head.appendChild(link);
  });
};

// Optimize third-party scripts loading
export const loadThirdPartyScripts = () => {
  // Load non-critical scripts after page load
  window.addEventListener('load', () => {
    // Example: Load analytics or other third-party scripts
    // This prevents them from blocking the initial page render
    
    // Placeholder for future third-party integrations
    console.log('Third-party scripts can be loaded here after page load');
  });
};

// Performance monitoring
export const measurePerformance = () => {
  if ('performance' in window) {
    window.addEventListener('load', () => {
      setTimeout(() => {
        const perfData = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        
        const metrics = {
          // Core Web Vitals approximations
          domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
          loadComplete: perfData.loadEventEnd - perfData.loadEventStart,
          firstByte: perfData.responseStart - perfData.requestStart,
          domInteractive: perfData.domInteractive - perfData.fetchStart,
          
          // Resource timing
          totalLoadTime: perfData.loadEventEnd - perfData.fetchStart,
          dnsLookup: perfData.domainLookupEnd - perfData.domainLookupStart,
          tcpConnect: perfData.connectEnd - perfData.connectStart,
        };

        // Log performance metrics in development
        if (import.meta.env.DEV) {
          console.table(metrics);
        }

        // Send to analytics in production (placeholder)
        if (import.meta.env.PROD) {
          // Send metrics to your analytics service
          console.log('Performance metrics:', metrics);
        }
      }, 0);
    });
  }
};

// Intersection Observer for lazy loading optimization
export const createIntersectionObserver = (
  callback: IntersectionObserverCallback,
  options?: IntersectionObserverInit
) => {
  const defaultOptions: IntersectionObserverInit = {
    root: null,
    rootMargin: '50px',
    threshold: 0.1,
    ...options
  };

  return new IntersectionObserver(callback, defaultOptions);
};

// Service Worker registration for caching
export const registerServiceWorker = async () => {
  if ('serviceWorker' in navigator && import.meta.env.PROD) {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js');
      console.log('Service Worker registered successfully:', registration);
    } catch (error) {
      console.log('Service Worker registration failed:', error);
    }
  }
};

// Memory usage monitoring (development only)
export const monitorMemoryUsage = () => {
  if (import.meta.env.DEV && 'memory' in performance) {
    setInterval(() => {
      const memInfo = (performance as any).memory;
      console.log('Memory usage:', {
        used: Math.round(memInfo.usedJSHeapSize / 1048576) + ' MB',
        total: Math.round(memInfo.totalJSHeapSize / 1048576) + ' MB',
        limit: Math.round(memInfo.jsHeapSizeLimit / 1048576) + ' MB'
      });
    }, 30000); // Log every 30 seconds
  }
};